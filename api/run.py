from flask import Flask, requestfrom flask_cors import CORS, cross_originimport jsonimport sqlite3import pandas as pdimport numpy as npfrom datetime import datetime, datefrom urllib.parse import quoteimport requestsapp = Flask(__name__)CORS(app)def get_connection(db_path='foodship.db'):    return sqlite3.connect(db_path)@app.route('/checkemail', methods=["POST"])def if_user_exists():    email = request.form["email"]    conn = get_connection()    c = conn.cursor()    c.execute("SELECT * FROM user WHERE email=(?)", [email])    users = c.fetchall()    conn.close()    if len(users) == 0:        return json.dumps("success")    else:        return json.dumps("exists")@app.route('/adduser', methods=["POST"])def add_user():    request_data = request.get_json()    username = request_data["username"]    password = request_data["password"]    gender = request_data["gender"]    major = request_data["major"]    email = request_data["email"]    pref1 = request_data["pref1"]    pref2 = request_data["pref2"]    pref3 = request_data["pref3"]    notes = request_data["notes"]    conn = get_connection()    c = conn.cursor()    c.execute("INSERT INTO user (firstName, password, gender, email, major, pref_1, pref_2, pref_3, summary) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",            [username, password, gender, email, major, pref1, pref2, pref3, notes])    conn.commit()    conn.close()    response_text = {}    response_text["message"] = "Success"    return json.dumps(response_text)@app.route('/getuser', methods=["POST"])def get_user():    request_data = request.get_json()    email = request_data["email"]    conn = get_connection()    c = conn.cursor()    c.execute("SELECT firstName, password, gender, email, major, pref_1, pref_2, pref_3, summary FROM user WHERE email=(?)", [email])    users = c.fetchall()    conn.close()    if len(users) == 0:        return json.dumps({"message": "Email doesn't exists."})    else:        user = users[0]        return json.dumps({"message": "success", "data": user})if __name__ == "__main__":    conn = get_connection()    c = conn.cursor()    c.execute("SELECT * FROM user")    users = c.fetchall()    conn.close()    print(users)@app.route("/history",methods=["GET"])def get_history():    email = request.args.get("user")    conn = sqlite3.connect('foodship.db')    c = conn.cursor()    c.execute("SELECT firstName from user where email='"+email+"'")    record = c.fetchone()    username = record[0]    c.execute("SELECT cuisine, day, meal, restaurant, companion, status, initiator from dining_option where email1='"+email+"' or emai2='"+email+"'")    records = c.fetchall()    conn.close()    return_data = list()    for record in records:        record_dict=dict()        record_dict["cuisine"]=record[0]        record_dict["date"]=record[1]        record_dict["meal"]=record[2]        record_dict["restaurant"]=record[3]        if(username==record[4]):            record_dict["companion"]=record[6]        else:            record_dict["companion"]=record[4]        record_dict["status"]=record[5]        return_data.append(record_dict)    return json.dumps(return_data)@app.route("/username",methods=["GET"])def getuser():    email = request.args.get("user")    conn = sqlite3.connect('foodship.db')    c = conn.cursor()    c.execute("SELECT firstName from user where email= '%s'" % email)    record = c.fetchone()    conn.close()    username = record[0]    return_data={'firstname':username}    return json.dumps(return_data)@app.route('/browse',methods=["GET"])def get_dining_option():    conn = get_connection()    c = conn.cursor()    request_data = request.get_json()    email = request_data["email"]    today = date.today()    day = str(today.month)+'/'+str(today.day)+'/'+str(today.year)[2:]    c.execute("SELECT firstName,pref_1,pref_2,pref_3 FROM user WHERE email = '%s'" % email)    user_data = c.fetchone()    cuisine = user_data[1:]    c.execute("SELECT initiator,cuisine,budget,day,sequence FROM dining_option WHERE status = 'unmatched' AND email1!='%s' AND day>='%s' AND (cuisine = '%s' OR cuisine = '%s' OR cuisine = '%s')" % (email,day,cuisine[0],cuisine[1],cuisine[2]))    lst = c.fetchall()    conn.close()    # idx: the index of all dining options qualified for recommendation    idx = np.arange(len(lst))    np.random.shuffle(idx)    # idx_chosen: 5 indices chosen    idx_chosen = idx[:5]    dining_chosen = [lst[i] for i in idx_chosen]    user = dict()    for i in range(0,5):        user[i+1] = {"name": dining_chosen[i][0],        "price": "$"*int(dining_chosen[i][2]),        "food": dining_chosen[i][1],        "time": dining_chosen[i][3],        "sequence": dining_chosen[i][4]        }    return json.dumps(user)# Yelp APIdef query_api(search_category, price):    term='restaurants'    location='Berkeley, CA'    search_limit=1    bearer_token = '_L-9LytjgPnpW5iSOEAqex9hABPGfq6-C-S1uRFuwkkGnlaDM9CFq1uAixXL6YGXPLVyn9JXiE9esrRAy1cmluMcBSc7QBhAg2yrSxGd7MD3EquAnZSaQyrSnsfvWXYx'    API_HOST = 'https://api.yelp.com'    SEARCH_PATH = '/v3/businesses/search'    url_params = {        'term': term.replace(' ', '+'),        'location': location.replace(' ', '+'),        'limit': search_limit,        'categories': search_category,        'price': price    }        url_params = url_params or {}    url = '{0}{1}'.format(API_HOST, quote(SEARCH_PATH.encode('utf8')))    headers = {        'Authorization': 'Bearer %s' % bearer_token,    }    response = requests.request('GET', url, headers=headers, params=url_params).json()    businesses = response.get('businesses')    return businesses@app.route('/<sequence>',methods=["GET"])def get_email(sequence):    conn = get_connection()    c = conn.cursor()    c.execute("SELECT email1,initiator,cuisine,budget,day,meal FROM dining_option WHERE sequence = '%s'" % sequence)    info = c.fetchall()    # one observation    cate = info[0][2]    budget = info[0][3]    day = info[0][4]    meal =info[0][5]    price = "$"*int(budget)    try:        business =query_api(cate,budget)[0]        name = business['name']        address = '<br>'.join(business['location']['display_address'])        rating = business['rating']        image_url = business['image_url']        url = business['url']        restaurant_chosen = (name,address,rating,0,url,image_url)    except:        c.execute("SELECT id,location,rating,review_count,image_url,url FROM restaurant WHERE categorie = ? AND price = ?",(cate,price))        restaurants = c.fetchall()        if len(restaurants) == 0:            print("find")            c.execute("SELECT id,location,rating,review_count,image_url,url FROM restaurant WHERE categorie = ?",[cate])            restaurants = c.fetchall()        conn.close()        idx = np.arange(len(restaurants))        np.random.shuffle(idx)        idx_chosen = idx[0]        restaurant_chosen = restaurants[idx_chosen] # [name,address,rating,review_count,url,image_url]    rec = info[0] + restaurant_chosen    return json.dumps(rec)@app.route('/<sequence>',methods=["POST"])def change_status(sequence):    data = request.get_json()    conn = get_connection()    c = conn.cursor()    c.execute("SELECT status from dining_option where sequence=?",[sequence])    status = c.fetchone()[0]    if status=='matched':        conn.close()        return json.dumps({"message":"wrong"}),400, {'ContentType':'application/json'}    else:        companion=data["username"]        email2=data["emai2"]        resto = data["resto"]        c.execute("UPDATE dining_option SET status = (?),companion=(?),emai2=(?), restaurant=(?) WHERE sequence = (?) ",("matched",companion,email2, resto, sequence))        conn.commit()        conn.close()        return json.dumps({"message":"success"}),200, {'ContentType':'application/json'}@app.route("/match",methods=["GET"])def get_match():    cuisine = request.args.get('cuisine')    date = request.args.get('date')    date_object = datetime.strptime(date[:-2]+'20'+date[-2:], '%m/%d/%Y').date()    meal = request.args.get('meal')    budget = request.args.get('budget')    # define location dictionary    lng_lat_dic = {'american':[+37,-99],'ethiopian':[+10,+40],'russian':[+61,+99],'indian':[+20,+85],'chinese':[+40,+120],'japanese':[+39,+138],                   'french':[+47,+2],'spanish':[+40,-4],'mediterranian':[+38,+15],'korean':[+36,+128],'thai':[+14,+101],'mexican':[+19,-99],'italian':[+42,+13]}    # connect database    conn = sqlite3.connect('foodship.db')    c = conn.cursor()    # select all from table dining_option where cuisine equals to user's preference    c.execute("SELECT * FROM dining_option WHERE cuisine = (?)",[cuisine])    selectedBasedOnCuisine = c.fetchall()    if len(selectedBasedOnCuisine)<3:        lng_lat_df = pd.DataFrame(lng_lat_dic,index=['lng','lat']).transpose()        # find nearest countries using Euclidean distance        cuisine_options = np.sqrt(np.sum(np.power(lng_lat_df-lng_lat_df.loc[cuisine],2),axis=1)).sort_values().index.tolist()        c.execute("SELECT * FROM dining_option WHERE cuisine = (?) OR cuisine = (?) OR cuisine = (?)",[cuisine_options[0],cuisine_options[1],cuisine_options[2]])        selectedBasedOnCuisine = c.fetchall()    columns = [i[1] for i in c.execute("PRAGMA table_info([dining_option])").fetchall()]    # select using pandas    df = pd.DataFrame(selectedBasedOnCuisine,columns=columns)    date_df = pd.DataFrame([datetime.strptime(d[:-2]+'20'+d[-2:], '%m/%d/%Y').date() for d in df.day],columns=['date'])    df = pd.merge(df,date_df,right_index=True, left_index=True)    df = df.set_index('sequence')    df['date_diff'] = (df.date - date_object).apply(lambda x:x.days)    df['meal_diff'] = df['meal'].apply(lambda x:meal.find(x))    df['budget_diff'] = df['budget'].apply(lambda x:abs(int(budget)-int(x)))    selected_dining = df[(df['date_diff']>=0) & (df['status']=='unmatched')].sort_values(by=['date_diff','meal_diff','budget_diff'], ascending=[1, 0,1])    # put data in json    returen_data = json.loads(selected_dining.iloc[:3][['initiator','budget', 'cuisine', 'day', 'meal']].to_json(orient='index'))    returen_data['userInfo'] = {'cuisine':cuisine,'date':date,'meal':meal,'budget':budget}    conn.close()    return json.dumps(returen_data), 200, {'ContentType':'application/json'}@app.route("/create",methods=["POST"])def create_own():    conn = sqlite3.connect('foodship.db')    c = conn.cursor()    request_data = request.get_json()    email1 = request_data["email"]    cuisine = request_data["cuisine"]    date = request_data["day"]    meal = request_data["meal"]    budget = request_data["budget"]    # from table user select the user's information    c.execute("SELECT * FROM user WHERE email = (?)",[email1])    selectedUser = c.fetchall()    initiator = selectedUser[0][0]    gender = selectedUser[0][1]    # calculate the sequence number    existedRow = c.execute("SELECT COUNT(sequence) FROM dining_option").fetchall()[0][0]    sequence = str(existedRow+1)    # insert data into table dining_option    columns = [i[1] for i in c.execute("PRAGMA table_info([dining_option])").fetchall()]    c.execute("INSERT INTO dining_option ("+','.join(columns)+") VALUES (?,?,?,?,?,?,?,?,?,?,?,?)", [sequence, initiator, budget, cuisine, gender, 'unknown', date, meal, email1, 'unknown', 'unknown', 'unmatched'])    conn.commit()    # judge whether the insert commit is successful    confirm = c.execute("SELECT * FROM dining_option WHERE sequence = (?)",[sequence]).fetchall()    conn.close()    if confirm == []:        return json.dumps({'success':False}), 500, {'ContentType':'application/json'}    else:        return json.dumps({'success':True}), 200, {'ContentType':'application/json'}